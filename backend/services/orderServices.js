const mongoose = require('mongoose');
const Order = require('../models/orderSchema');
const Cart = require('../models/cartSchema');
const CartItem = require('../models/cartItemSchema');
const Product = require('../models/productSchema');

async function createOrderFromCart(userId, orderData) {
  try {
    console.log('üöÄ Checkout started for user:', userId);
    
    // Get user's cart
    const cart = await Cart.findOne({ user: userId })
      .populate({
        path: 'items',
        populate: {
          path: 'product',
          select: 'name price discount quantity'
        }
      });
    
    console.log('üõí Cart found:', cart ? 'YES' : 'NO');
    console.log('üì¶ Cart items:', cart?.items?.length || 0);
    
    if (!cart || cart.items.length === 0) {
      throw new Error('Cart is empty');
    }
    
    // Check stock availability
    for (const item of cart.items) {
      const product = await Product.findById(item.product._id);
      if (!product) {
        throw new Error(`Product ${item.product._id} not found`);
      }
      if (product.quantity < item.quantity) {
        throw new Error(`Insufficient stock for ${product.name}. Only ${product.quantity} available.`);
      }
    }
    
    // Create order - orderNumber will be auto-generated by middleware
    const order = new Order({
      user: userId,
      subtotal: cart.subtotal,
      shipping: cart.shipping,
      total: cart.total,
      deliveryAddress: orderData.deliveryAddress,
      customerPhone: orderData.customerPhone,
      customerNotes: orderData.customerNotes
    });
    
    console.log('üìù Order created (pre-save):', order);
    
    // Save order first to get ID (and auto-generate orderNumber)
    const savedOrder = await order.save();
    console.log('‚úÖ Order saved with number:', savedOrder.orderNumber);
    
    // Link CartItems to this order and reduce stock
    for (const cartItem of cart.items) {
      // Link CartItem to order
      await CartItem.findByIdAndUpdate(
        cartItem._id, 
        { order: savedOrder._id },
        { new: true }
      );
      console.log(`üîó Linked CartItem ${cartItem._id} to order`);
      
      // Reduce product stock
      await Product.findByIdAndUpdate(
        cartItem.product._id,
        { $inc: { quantity: -cartItem.quantity } }
      );
      console.log(`üìâ Reduced stock for product ${cartItem.product._id}`);
    }
    
    // Update order with cart items
    savedOrder.items = cart.items.map(item => item._id);
    await savedOrder.save();
    console.log('‚úÖ Order updated with items');
    
    // Clear cart
    cart.items = [];
    cart.subtotal = 0;
    cart.total = 0;
    await cart.save();
    console.log('üõí Cart cleared');
    
    // Return populated order
    const populatedOrder = await Order.findById(savedOrder._id)
      .populate({
        path: 'items',
        populate: {
          path: 'product',
          select: 'name price images'
        }
      })
      .populate('user', 'name email');
    
    console.log('üéâ Checkout completed successfully');
    return populatedOrder;
      
  } catch (error) {
    console.error('‚ùå Create order error:', error);
    throw error;
  }
}

async function getCustomerOrders(userId) {
  try {
    const orders = await Order.find({ user: userId })
      .populate({
        path: 'items',
        populate: {
          path: 'product',
          select: 'name images'
        }
      })
      .sort({ createdAt: -1 });
    
    return orders;
  } catch (error) {
    console.error('Get customer orders error:', error);
    throw error;
  }
}

async function getAllOrders({ page = 1, limit = 20, status = null }) {
  try {
    const skip = (page - 1) * limit;
    const filter = {};
    
    if (status) filter.orderStatus = status;
    
    const orders = await Order.find(filter)
      .skip(skip)
      .limit(limit)
      .populate('user', 'name email phone')
      .populate({
        path: 'items',
        populate: {
          path: 'product',
          select: 'name price'
        }
      })
      .sort({ createdAt: -1 });
    
    const total = await Order.countDocuments(filter);
    
    return {
      orders,
      total,
      page,
      pages: Math.ceil(total / limit)
    };
  } catch (error) {
    console.error('Get all orders error:', error);
    throw error;
  }
}

async function getOrderById(orderId) {
  try {
    const order = await Order.findById(orderId)
      .populate('user', 'name email phone')
      .populate({
        path: 'items',
        populate: {
          path: 'product',
          select: 'name price images description'
        }
      });
    
    if (!order) throw new Error('Order not found');
    
    return order;
  } catch (error) {
    console.error('Get order by ID error:', error);
    throw error;
  }
}

async function updateOrderStatus(orderId, status) {
  try {
    const order = await Order.findByIdAndUpdate(
      orderId,
      { orderStatus: status },
      { new: true, runValidators: true }
    ).populate('user', 'name email');
    
    if (!order) throw new Error('Order not found');
    
    return order;
  } catch (error) {
    console.error('Update order status error:', error);
    throw error;
  }
}

orderSchema.pre('validate', function(next) {
  console.log('üîß Order validation middleware running');
  if (!this.orderNumber) {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    this.orderNumber = `ORD${year}${month}${day}${random}`;
    console.log('‚úÖ Generated order number:', this.orderNumber);
  }
  
});


module.exports = {
  createOrderFromCart,
  getCustomerOrders,
  getAllOrders,
  getOrderById,
  updateOrderStatus
};
